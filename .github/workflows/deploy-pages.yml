name: Deploy GitHub Pages

on:
  push:
    branches: ["main"]
  workflow_run:
    workflows: ["Daily Stock Data Update"]
    types: [completed]
  workflow_dispatch:

permissions:
  contents: write
  pages: write
  id-token: write

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    if: ${{ github.event_name != 'workflow_run' || github.event.workflow_run.conclusion == 'success' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.23'

      - name: Download latest DBs from release
        continue-on-error: true
        run: |
          mkdir -p data
          LATEST_TAG=$(curl -s https://api.github.com/repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
          
          if [ "$LATEST_TAG" != "null" ] && [ "$LATEST_TAG" != "" ]; then
            echo "üì• Downloading DBs from release: $LATEST_TAG"
            
            # 3-DBÊßãÊàê
            for DB_NAME in xbrl.db stock_price.db rs.db; do
              curl -L -o "data/${DB_NAME}.gz" \
                "https://github.com/${{ github.repository }}/releases/download/$LATEST_TAG/${DB_NAME}.gz" \
                2>/dev/null || echo "‚ö†Ô∏è $DB_NAME not found"
              
              if [ -f "data/${DB_NAME}.gz" ]; then
                gunzip "data/${DB_NAME}.gz"
                echo "‚úÖ $DB_NAME restored"
              fi
            done
            
            # „É¨„Ç¨„Ç∑„ÉºDBÂØæÂøú
            if [ ! -f data/xbrl.db ]; then
              echo "  Trying legacy stock_data.db..."
              curl -L -o data/stock_data.db.gz \
                "https://github.com/${{ github.repository }}/releases/download/$LATEST_TAG/stock_data.db.gz" \
                2>/dev/null || true
              if [ -f data/stock_data.db.gz ]; then
                gunzip data/stock_data.db.gz
                echo "  ‚úÖ Legacy DB restored (migration will run)"
              fi
            fi
            
            echo "üìä DB stats:"
            if [ -f data/xbrl.db ]; then
              sqlite3 data/xbrl.db "SELECT '  Stocks: ' || COUNT(*) FROM stocks;" 2>/dev/null || true
            fi
            if [ -f data/stock_price.db ]; then
              sqlite3 data/stock_price.db "SELECT '  Prices: ' || COUNT(DISTINCT code) FROM stock_prices;" 2>/dev/null || true
            fi
          else
            echo "‚ÑπÔ∏è No previous release found"
          fi

      - name: Fallback - Generate fresh data if no DB
        if: ${{ hashFiles('data/xbrl.db') == '' && hashFiles('data/stock_data.db') == '' }}
        run: |
          mkdir -p data
          TODAY=$(date -u +%Y-%m-%d)
          echo "üöÄ No existing DB, fetching fresh data for: $TODAY"
          go run main.go -mode=run -date=$TODAY
        env:
          EDINET_API_KEY: ${{ secrets.EDINET_API_KEY }}

      - name: Generate JSON for GitHub Pages
        run: |
          cat <<'EOF' > gen_json.go
          package main
          import (
              "database/sql"
              "encoding/json"
              "fmt"
              "os"
              _ "modernc.org/sqlite"
          )
          type StockJSON struct {
              Code              string  `json:"Code"`
              Name              string  `json:"Name"`
              UpdatedAt         string  `json:"UpdatedAt"`
              NetSales          int64   `json:"NetSales"`
              OperatingIncome   int64   `json:"OperatingIncome"`
              NetIncome         int64   `json:"NetIncome"`
              TotalAssets       int64   `json:"TotalAssets"`
              NetAssets          int64   `json:"NetAssets"`
              CurrentAssets     int64   `json:"CurrentAssets"`
              Liabilities       int64   `json:"Liabilities"`
              CurrentLiabilities int64  `json:"CurrentLiabilities"`
              CashAndDeposits   int64   `json:"CashAndDeposits"`
              SharesIssued      int64   `json:"SharesIssued"`
              LastPrice         float64 `json:"LastPrice"`
              PriceDate         *string `json:"PriceDate"`
          }
          func main() {
              // xbrl.db „Çí„É°„Ç§„É≥„Å®„Åó„Å¶Èñã„Åè
              dbPath := "./data/xbrl.db"
              if _, err := os.Stat(dbPath); os.IsNotExist(err) {
                  // „É¨„Ç¨„Ç∑„ÉºDB
                  dbPath = "./data/stock_data.db"
              }
              
              db, err := sql.Open("sqlite", dbPath)
              if err != nil { fmt.Println("DB open error:", err); os.Exit(1) }
              defer db.Close()

              // stock_price.db „Çí„Ç¢„Çø„ÉÉ„ÉÅ
              priceDBPath := "./data/stock_price.db"
              if _, err := os.Stat(priceDBPath); err == nil {
                  db.Exec("ATTACH DATABASE './data/stock_price.db' AS price_db")
              }

              // „ÇØ„Ç®„É™: stock_price.db „Åå„Ç¢„Çø„ÉÉ„ÉÅ„Åï„Çå„Å¶„ÅÑ„ÇãÂ†¥Âêà
              query := `
                  SELECT s.code, s.name, COALESCE(s.updated_at, ''),
                      COALESCE(s.net_sales, 0), COALESCE(s.operating_income, 0), COALESCE(s.net_income, 0),
                      COALESCE(s.total_assets, 0), COALESCE(s.net_assets, 0), COALESCE(s.current_assets, 0),
                      COALESCE(s.liabilities, 0), COALESCE(s.current_liabilities, 0),
                      COALESCE(s.cash_and_deposits, 0), COALESCE(s.shares_issued, 0),
                      0, NULL
                  FROM stocks s
                  ORDER BY s.code ASC
              `
              
              // price_db „Åå„Ç¢„Çø„ÉÉ„ÉÅ„Åï„Çå„Å¶„ÅÑ„Çå„Å∞Ê†™‰æ°„ÇÇÁµêÂêà
              var hasPriceDB bool
              db.QueryRow("SELECT 1 FROM price_db.stock_prices LIMIT 1").Scan(&hasPriceDB)
              if hasPriceDB {
                  query = `
                      SELECT s.code, s.name, COALESCE(s.updated_at, ''),
                          COALESCE(s.net_sales, 0), COALESCE(s.operating_income, 0), COALESCE(s.net_income, 0),
                          COALESCE(s.total_assets, 0), COALESCE(s.net_assets, 0), COALESCE(s.current_assets, 0),
                          COALESCE(s.liabilities, 0), COALESCE(s.current_liabilities, 0),
                          COALESCE(s.cash_and_deposits, 0), COALESCE(s.shares_issued, 0),
                          COALESCE(p.close, 0), p.date
                      FROM stocks s
                      LEFT JOIN (
                          SELECT code, close, date,
                              ROW_NUMBER() OVER (PARTITION BY code ORDER BY date DESC) as rn
                          FROM price_db.stock_prices
                      ) p ON s.code = p.code AND p.rn = 1
                      ORDER BY s.code ASC
                  `
              }
              
              rows, err := db.Query(query)
              if err != nil { fmt.Println("Query error:", err); os.Exit(1) }
              defer rows.Close()
              
              var stocks []StockJSON
              for rows.Next() {
                  var s StockJSON
                  var priceDate sql.NullString
                  rows.Scan(&s.Code, &s.Name, &s.UpdatedAt,
                      &s.NetSales, &s.OperatingIncome, &s.NetIncome,
                      &s.TotalAssets, &s.NetAssets, &s.CurrentAssets,
                      &s.Liabilities, &s.CurrentLiabilities,
                      &s.CashAndDeposits, &s.SharesIssued,
                      &s.LastPrice, &priceDate)
                  if priceDate.Valid {
                      s.PriceDate = &priceDate.String
                  }
                  stocks = append(stocks, s)
              }
              jsonData, _ := json.MarshalIndent(stocks, "", "  ")
              os.WriteFile("./web/stocks.json", jsonData, 0644)
              fmt.Printf("‚úÖ Generated stocks.json with %d records\n", len(stocks))
              
              withSales := 0
              withPrice := 0
              for _, s := range stocks {
                  if s.NetSales > 0 { withSales++ }
                  if s.LastPrice > 0 { withPrice++ }
              }
              fmt.Printf("  With sales: %d, With price: %d\n", withSales, withPrice)
          }
          EOF
          go mod tidy
          go run gen_json.go

      - name: Prepare Public Assets
        run: |
          mkdir -p public
          cp -r web/* public/
          echo "üìÅ Contents of public/:"
          ls -la public/

      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './public'

      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4